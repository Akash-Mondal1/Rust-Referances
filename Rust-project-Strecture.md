
# Rust Project Structures: Comprehensive Guide

This document provides a breakdown of **all possible approaches to structuring Rust projects**. Each approach includes steps, sample code, and best practices. This guide aims to help developers choose the right architecture based on their project requirements.

---

## 1. Single-Crate Project (Default Cargo Structure)

This is the **default structure** generated by `cargo new`. All code resides in a single **`src/` folder**.

### Steps to Create:
```bash
cargo new my_project --lib
cd my_project
```

### Structure:
```
my_project/
├── Cargo.toml
└── src/
    ├── lib.rs     # Library entry point.
    ├── module1.rs # Optional additional module.
    └── module2.rs # Optional additional module.
```

### Usage:
- All logic resides inside `src/`.
- Add multiple modules within `src/` and use `mod` to import them in `lib.rs`.

```rust
// src/lib.rs
pub mod module1;
pub mod module2;
```

This approach is best for **simple libraries or small projects** with limited complexity.

---

## 2. Cargo Workspace with Sub-Crates (Like `rust-bitcoin`)

This is the **modular approach** used by `rust-bitcoin`. It involves **multiple sub-crates** inside a single **workspace** with **local path dependencies** between them.

### Steps to Create:
```bash
mkdir my_workspace && cd my_workspace
cargo new addresses --lib
cargo new bitcoin --lib
cargo new primitives --lib
```

Create a **`Cargo.toml`** file at the **root** of your project to manage the workspace:

```bash
touch Cargo.toml
```

### Structure:
```
my_workspace/
├── Cargo.toml                # Workspace configuration.
├── addresses/                # Sub-crate 1.
│   ├── Cargo.toml
│   └── src/
│       └── lib.rs
├── bitcoin/                  # Sub-crate 2.
│   ├── Cargo.toml
│   └── src/
│       └── lib.rs
└── primitives/               # Sub-crate 3.
    ├── Cargo.toml
    └── src/
        └── lib.rs
```

### Root `Cargo.toml` Configuration:
```toml
[workspace]
members = ["addresses", "bitcoin", "primitives"]
```

### Add Dependencies in Sub-Crates:
```toml
# Example in bitcoin/Cargo.toml
[dependencies]
primitives = { path = "../primitives" }
```

This approach promotes modularity, allowing components to evolve independently.

---

## 3. Monorepo with Multiple Binaries and Libraries

A **monorepo** contains both **multiple binaries** and **libraries** within a single workspace. Each **binary** has its own entry point, and multiple libraries may share logic between binaries.

### Steps to Create:
```bash
mkdir my_monorepo && cd my_monorepo
cargo new cli-tool --bin
cargo new lib-core --lib
cargo new web-api --bin
```

### Structure:
```
my_monorepo/
├── Cargo.toml               # Workspace configuration.
├── cli-tool/                # Binary 1.
│   ├── Cargo.toml
│   └── src/
│       └── main.rs
├── lib-core/                # Shared library.
│   ├── Cargo.toml
│   └── src/
│       └── lib.rs
└── web-api/                 # Binary 2.
    ├── Cargo.toml
    └── src/
        └── main.rs
```

### Configuration:
```toml
[workspace]
members = ["cli-tool", "lib-core", "web-api"]
```

This structure works well for **complex applications** with CLI tools, APIs, and shared logic.

---

## 4. Layered Architecture Using Feature Flags

This approach allows developers to **dynamically enable or disable parts of the project** using **feature flags**. 

### Steps to Create:
```bash
cargo new layered_project --lib
cd layered_project
```

### Modify **Cargo.toml** for Feature Flags:
```toml
[features]
default = ["full"]
full = ["db", "network"]
db = []
network = []
```

### Structure:
```
layered_project/
├── Cargo.toml
└── src/
    ├── lib.rs
    ├── db.rs      # DB logic (optional).
    └── network.rs # Network logic (optional).
```

### Use Conditional Compilation in Code:
```rust
// src/lib.rs
#[cfg(feature = "db")]
pub mod db;

#[cfg(feature = "network")]
pub mod network;
```

### Build with Feature Flags:
```bash
cargo build --features "db network"
```

This approach is useful for **flexible libraries** with optional or experimental features.

---

## 5. Crate with Plugin System or Dynamic Modules

This approach uses **dynamic loading of modules** to add functionality at runtime. It is commonly used in **game engines or customizable systems**.

### Steps to Create:
```bash
cargo new plugin_host --bin
cd plugin_host
```

Create a **plugins/ folder** to house plugin modules:

```
plugin_host/
├── Cargo.toml
├── plugins/
│   ├── plugin1/
│   │   ├── Cargo.toml
│   │   └── src/lib.rs
│   └── plugin2/
│       ├── Cargo.toml
│       └── src/lib.rs
└── src/
    └── main.rs
```

### Use Dynamic Loading in `main.rs`:
```rust
fn main() {
    println!("Loading plugins...");
    // Logic to dynamically load plugins from the plugins/ directory.
}
```

This structure is ideal for **extensible systems** where functionality can be added at runtime.

---

## **Summary Table**

| **Approach**                  | **Description**                                          | **Use Case**                               |
|-------------------------------|----------------------------------------------------------|--------------------------------------------|
| Single-Crate Project           | All code in `src/` folder.                               | Simple projects or small libraries.       |
| Workspace with Sub-Crates      | Multiple related crates in one workspace.                | Large libraries like `rust-bitcoin`.      |
| Monorepo with Binaries & Libs  | Multiple binaries and libraries in one repo.             | Complex apps with CLI and APIs.           |
| Layered with Feature Flags     | Enable/disable components using Cargo features.          | Flexible libraries with optional logic.   |
| Plugin System with Dynamic Modules | Load components dynamically at runtime.            | Game engines or extensible systems.       |

---

## Conclusion

This guide covers the most common **approaches to structuring Rust projects**, with practical examples and explanations. Choose the right structure based on your project needs, whether it’s a **simple library, complex monorepo, or modular workspace**.
